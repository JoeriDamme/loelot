import BadRequestError, { IBadRequestErrors } from './errors/bad-request.error';

export default class SequelizeUtility {
  /**
   * Wrapper method around getMissingMandatoryAttributes. Will throw BadRequestError in case attributes are missing.
   * @param model
   * @param properties
   * @param exception
   * @throws BadRequestError
   */
  public static hasMandatoryAttributes(model: any, properties: string[], exception: string[] = []): void {
    const missingProperties: string[] = SequelizeUtility.getMissingMandatoryAttributes(model, properties, exception);

    if (missingProperties.length) {
      const missingPropertiesErrors: IBadRequestErrors[] = missingProperties.map((prop: string) => {
        return Object.assign({}, { message: `${model.name}.${prop} cannot be null`, property: prop});
      });

      throw new BadRequestError('Missing properties in request', missingPropertiesErrors);
    }
    return;
  }

  /**
   * Check if array of properties coming from the req.body contains all the mandatory
   * properties required in the model. Usefull to check if the req.body of a PUT requests
   * is having all the required properties.
   * It's also possible to send an array of exceptions, for example a value that is only been set during creation
   * but can't be patched or updated.
   * The method will return an array with missing properties, or empty in case of no missing properties.
   * @param model The Sequelize model.
   * @param properties All properties of the req.body.
   * @param exception Ignore these properties.
   * @returns Array with missing properties, or an empty array if every mandatory attribute has been set.
   */
  public static getMissingMandatoryAttributes(model: any, properties: string[], exception: string[] = []): string[] {
    const mandatoryModelAttributes: string[] = Object.keys(model.rawAttributes).filter((attribute: string) => {
      if (model.rawAttributes[attribute].allowNull === false &&
        !model.rawAttributes[attribute]._autoGenerated &&
        !model.rawAttributes[attribute].primaryKey &&
        !exception.includes(attribute)) {
        return attribute;
      }
    });

    return mandatoryModelAttributes.filter((mandatoryAttribute: string) => {
      if (!properties.includes(mandatoryAttribute)) {
        return mandatoryAttribute;
      }
    });
  }
}
